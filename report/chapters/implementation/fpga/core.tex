\FloatBarrier
\subsection{Processor Core}\label{subsec:fpga-processor-core}
\todo[inline]{How the processor is designed and why}

\subsubsection{Considerations}

The processor core was implemented with focus on being quick in order to process
audio in real-time, as well as being power efficient to the degree permitted by
the FPGA chip. The higher the throughput, the quicker the execution time before
the whole system could be shut off again, thus reducing the power
consumption and increasing the energy-efficiency. As such, the processor core has been
designed with focus on the following principles:

\begin{itemize}
	\item As high throughput as possible.
	\item Support the instructions needed to perform the audio manipulations.
\end{itemize}

In order for the core to be as efficient as possible, a pipelined processor
design was implemented. The pipelined core design consists of the following
stages:

\begin{enumerate}
	\item Instruction Fetch \label{stage:if}
	\item Instruction Decode \label{stage:id}
	\item Memory \label{stage:mem}
	\item Execute \label{stage:ex}
	\item Writeback \label{stage:wb}
\end{enumerate}

A change from the classic pipelined processor desings, is that the memory
pipeline stage comes before the execution stage. This is because the load/store
instructions do not need the ALU during execution. Thus the project
implementation is able to prevent load dependecies by simple forwarding, instead
of wasting a pipeline clock-cycle by inserting a no-operation.

For simplicity, the core does not have a hazard control unit implemented for
branching, but instead relies on the programmer to add two no-operations after a
branch.\todo{Maybe we can have the assembly do this instead?? That would be
great.}

\subsubsection{Floating-point implementation design choices}

Some audio filters are performed in the time domain, others are performed in the
frequency domain. To convert the audio samples from one domain to the other, a
fourier transform (FT) and its inverse is usually employed. A discrete FT is
perfectly suited for the sample based nature of an audio processor. The FT we
chose to utilize for our project is the
sliding discrete fourier transform (SDFT), detailed in appendix \ref{appendix:sd-ft}.

With the goal of having a real-time sound processing system, the algorithmic
complexity of the SDFT would make it one of the more algorithmically
time-complex operations a processor core would have to complete within the
time window between two sample inputs.

Realizing an SDFT on a computing device requires floating point arithmetics.
Therefore, to lower the algorithmic complexity required for the floating point
calculations, a decision was made to lower the maximum size of the integers in
the audio samples to 8 bits. The consequence of this is that the maximum sound
frequency was reduced from the standard value of 44~KHz, down to approximately 11~KHz.
This reduces the amount of samples the processor core can process.

