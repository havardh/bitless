\chapter{Fourier-transform}
\section{Transformations}
Some audio filters are performed in the time domain, others are performed in the
frequency domain. \todo{illustration} To convert the audio samples from a domain
to the other a Fourier Transform or the inverse is usually employed. The
Discrete Fourier Transformed \todo{ref} is perfectly suited for the sample based
nature of a audio processor. This method has numerous optimized implementation,
most known is the Fast Fourier Transform\todo{ref}.

\subsection{Fast Fourier Transform}
The Fast Fourier Transform, FFT, takes a collection of N samples, $S$, as input
and returns the frequencies of this window in time, $FW$. On this frequency
window a frequency domain filter can be executed, which results in a filtered
window $FW_f$. This filtered window can then be transformed back to a collection
of filtered samples $S_f$ by utilizing the inverse Fast Fourier transform IFFT.
The time complexity of the FFT is $O(n) = n*log(n)$, to get a smoother result
the transform is usually performed on overlapping windows of the sample stream.
\missingfigure{illustration of overlapping windows}

\subsection{Sliding Discrete Fourier Transform}
The Sliding Discrete Fourier Transform\todo{ref} takes one sample, $s_1$, a
frequency domain $FW_0$, and a historic sample $s_n$ as input along with some
constant coefficients.
It returns the frequency domain window, $FW_1$ as altered by adding the input
sample, $s_1$ and removing the sample $s_n$. The frequency domain can be
initialized to all zeros and the same with the historic sample. The n value of
the historic sample correspond to the window size N in the FFT algorithm. The
time complexity of the SDFT algorithm is $O(n) = n$. The inverse SDT takes the
frequency window and the same constant coefficients as input and return exactly
one sample $s_f$.

\subsection{Integer Discrete Fourier Transform}
Both the SDFT and FFT can be performed with both
\todo{WRONG FOR THE SD-FT}integer and floating point arithmetic. The advantage
of using integer is the speed of integer arithmetic compared to floating point.
The integer version performs a worse approximation than the floating point
version. \todo{Not so sure this is correct either. The reasoning I'm aware of is
that integer FFT (not SD-FT) requires much bigger integers than 8-bit to get
useful results, as well as more area on the FPGA chip.}

\begin{enumerate}
\item DFT - Discrete Fourier Transform
	\begin{itemize}
	  \item FFT - Fast Fourier Transform
		\item SDFT - Sliding Discrete Fourier Transform
		\item IDFT - Integer Discrete Fourier Transform
	\end{itemize}
\end{enumerate}