\section{ISA}

\subsection{First Draft}
It was decided to use a processor architecture with 16-bit instruction words and 32 general purpose registers.
The instructions are divided in three different classes, load/store instructions, arithmetic instructions
and miscellaneous instructions. All instructions have a common group field in the two most significant bits,
which is used to select between one of four instruction groups, as shown in table \ref{tab:group_fmt}.

It was decided to use four condition flags, listed in table \ref{tab:condition_flags}. These are stored in
a dedicated status and control register.

\input{figures/fpga/isa-group-format}
\input{figures/fpga/isa-condition-flags}

\subsubsection{Load/store instructions}
The format of load/store instructions is illustrated in figure \ref{fig:ls_instr_format}. The possible
instructions are listed in table \ref{tab:ls_instrs}.

\input{figures/fpga/isa-load-store-format}
\input{figures/fpga/isa-load-store-instruction}

\subsubsection{Arithmetic instructions}
The format of the arithmetic instructions is illustrated in figure \ref{fig:arith_instr_format}. The Implemented
instructions are listed in table \ref{tab:arith_instrs}. In order to support other variants of the same instructions,
such as add-with-carry or multiply-and-accumulate, an option field has been added. The operations are implemented such
that the result of an operation is written back to the first operand register, $ra = ra~op~rb$.

\input{figures/fpga/isa-arithmetic-instruction}
\input{figures/fpga/isa-arithmetic-implemented}

\subsubsection{Miscellaneous instructions}
The format of the miscellaneous instructions is illustrated in figure \ref{fig:misc_instr_format}. The
implemented instructions are listed in table \ref{tab:misc_instrs}.

\input{figures/fpga/isa-misc-instruction}
\input{figures/fpga/isa-misc-implemented}

\FloatBarrier
\subsection{Second Draft}

Due to the requirements of running an FFT on the processor, floating point instructions for doing additions,
multiplications and subtractions were added. In addition, some instructions in the arithmetic group changed
format, and immediate forms were added for some functions. Some new data movement instructions were added,
especially due to the addition of a separate memory area for storing constants, and their format was changed.

\subsection{Register-based instructions}

The group previously named arithmetic operations now contains most of the implemented instructions, including
load/store instructions. They all have in common that they have at least one register as operand. The format
of the instructions is illustrated in figure \ref{fig:regbased_instrs_format}. The implemented functions can be
found in table \ref{tab:regbased_instrs}.

\begin{figure}[h]
	\centering
	\begin{bytefield}[endianness=big,bitwidth=0.05\linewidth]{16}
		\bitheader{0-15} \\
		\bitbox{2}{Group} &
		\bitbox{2}{Funct} &
		\bitbox{2}{Opt}   &
		\bitbox{5}{Reg A} &
		\bitbox{5}{Reg B/Imm} 
	\end{bytefield}

	\caption{Register-based instruction format}
	\label{fig:regbased_instrs_format}
\end{figure}

\begin{table}[h]
    \centering
    \begin{tabular}{|l l l l l|}
        \hline
        \textbf{Funct} & \textbf{Opt}  & \textbf{Mnemonic} & \textbf{Instruction} & \textbf{Operation} \\
	\hline
	\multicolumn{5}{|c|}{Group \texttt{0b00}} \\
	\hline
	\multirow{3}{*}{\texttt{0b00}}
		& \texttt{0b00} & \texttt{add \$ra, \$rb}  & Add registers & $\$ra \leftarrow \$ra + \$rb$ \\
		& \texttt{0b01} & \texttt{addi \$ra, imm} & Add immediate & $\$ra \leftarrow \$ra + imm$ \\
		& \texttt{0b10} & \texttt{fadd \$ra, \$rb} & Add registers (FP) & $\$ra \leftarrow \$ra + \$rb$ \\
	\multirow{4}{*}{\texttt{0b01}}
		& \texttt{0b00} & \texttt{sub \$ra, \$rb}  & Subtract registers & $\$ra \leftarrow \$ra - \$rb$ \\
		& \texttt{0b01} & \texttt{fsub \$ra, \$rb} & Subtract registers (FP) & $\$ra \leftarrow \$ra - \$rb$ \\
		& \texttt{0b10} & \texttt{cmp \$ra, \$rb}  & Compare & $cnd \leftarrow cnd(\$ra - \$rb)$ \\
		& \texttt{0b11} & - & compare fp / subtract imm? & - \\
	\multirow{4}{*}{\texttt{0b10}}
		& \texttt{0b00} & \texttt{mul \$ra, \$rb}  & Multiply registers & $\$ra \leftarrow \$ra * \$rb$ \\
		& \texttt{0b01} & \texttt{fmul \$ra, \$rb} & Multiply registers (FP) & $\$ra \leftarrow \$ra * \$rb$ \\
		& \texttt{0b10} & \texttt{fmla \$ra, \$rb} & Multiply-and-accumulate (FP) & $\$ra \leftarrow \$ra + \$rb * \$rc$ \\
		& \texttt{0b11} & \texttt{fmls \$ra, \$rb} & Multiply-and-subtract (FP) & $\$ra \leftarrow \$ra - \$rb * \$rc$ \\
	\multirow{2}{*}{\texttt{0b11}}
		& \texttt{0b00} & \texttt{shl \$ra, imm} & Shift left & $\$ra \leftarrow \$ra << imm$ \\
		& \texttt{0b01} & \texttt{shr \$ra, imm} & Shift right & $\$ra \leftarrow \$ra >> imm$\\
	\hline
	\multicolumn{5}{|c|}{Group \texttt{0b01}} \\
	\hline
	\multirow{2}{*}{\texttt{0b00}}
		& \texttt{0b00} & \texttt{and \$ra, \$rb} & And & $\$ra \leftarrow \$ra \wedge \$rb$ \\
		& \texttt{0b01} & \texttt{nand \$ra, \$rb} & Nand & $\$ra \leftarrow \neg(\$ra \wedge \$rb)$ \\
	\multirow{3}{*}{\texttt{0b01}}
		& \texttt{0b00} & \texttt{or \$ra, \$rb} & Or & $\$ra \leftarrow \$ra \vee \$rb$ \\
		& \texttt{0b01} & \texttt{nor \$ra, \$rb} & Nor & $\$ra \leftarrow \neg(\$ra \vee \$rb)$\\
		& \texttt{0b10} & \texttt{xor \$ra, \$rb} & Xor & $\$ra \leftarrow \$ra \oplus \$rb$\\
	\multirow{4}{*}{\texttt{0b10}}
		& \texttt{0b00} & \texttt{mov \$ra, \$rb} & Move & $\$ra \leftarrow \$rb$\\
		& \texttt{0b01} & \texttt{mvn \$ra, \$rb} & Move negative & $\$ra \leftarrow \neg\$rb$ \\
		& \texttt{0b10} & \texttt{i2f \$ra, \$rb} & Typecast (Int to FP) & $\$ra \leftarrow fp(\$rb)$ \\
		& \texttt{0b11} & \texttt{f2i \$ra, \$rb} & Typecast (Fp to int) & $\$ra \leftarrow int(\$rb)$ \\
	\multirow{4}{*}{\texttt{0b11}}
		& \texttt{0b00} & \texttt{lda \$ra, [\$rb]} & Load from input & $\$ra \leftarrow [\$rb]$ \\
		& \texttt{0b01} & \texttt{ldb \$ra, [\$rb]} & Load from output & $\$ra \leftarrow [\$rb]$ \\
		& \texttt{0b10} & \texttt{ldc \$ra, [\$rb]} & Load from constant buffer & $\$ra \leftarrow [\$rb]$ \\
		& \texttt{0b11} & \texttt{stb \$ra, [\$rb]} & Store to output & $[\$rb] \leftarrow \$ra$ \\
	\hline
    \end{tabular}

    \caption{Register-based instruction list}
    \label{tab:regbased_instrs}
\end{table}

\subsection{Load immediate instruction}
The load immediate instruction is used to load an immediate constant into a register. The format of the instruction can
be found in figure \ref{fig:ldi_format}. The value is loaded into register \texttt{\$ri}.

\begin{figure}[h]
	\centering
	\begin{bytefield}[endianness=big,bitwidth=0.05\linewidth]{16}
		\bitheader{0-15} \\
		\bitbox{2}{Group} &
		\bitbox{13}{Imm}
	\end{bytefield}

	\caption{Load immediate format}
	\label{fig:ldi_format}
\end{figure}


\subsection{Branch instruction}
The branch instruction checks the condition flags and jumps accordingly. Using the four defined condition flags,
many different conditions can be checked for. The format of the instructions is illustrated in figure \ref{fig:new_branch_format}.
List of the encoding of the flags field is coming later.

\begin{figure}[h]
	\centering
	\begin{bytefield}[endianness=big,bitwidth=0.05\linewidth]{16}
		\bitheader{0-15} \\
		\bitbox{2}{Group} &
		\bitbox{4}{Flags} &
		\bitbox{11}{Target}
	\end{bytefield}

	\caption{Branch instruction format}
	\label{fig:new_branch_format}
\end{figure}


\subsubsection{Special registers}

Due to the limited space in instruction words, only two registers at most can be specified in an instruction.
Some instructions, such as the load immediate and load constant instructions do not specify any registers,
only an immediate offset constant.

The list of defined special registers can be found in table \ref{tab:specregs}. The register number for these
registers have not yet been determined.

\begin{table}[h]
	\centering
	\begin{tabular}{|l l|}
		\hline
		\textbf{Register name} & \textbf{Register purpose} \\
		\hline
		\texttt{r0} & Zero register, hard coded to always contain 0 \\
		\texttt{ri} & Immediate register, contains the result of an \textsc{ldi} instruction\\
		\texttt{rc} & Constant register, provides operand to \textsc{fmla} and \textsc{fmls} instructions \\
		\hline
	\end{tabular}

	\caption{List of special registers}
	\label{tab:specregs}
\end{table}

