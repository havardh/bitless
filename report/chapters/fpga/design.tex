\FloatBarrier
\section{Design Planning}\label{section:fpga-design}
\FloatBarrier
\subsection{Design start}

As soon as we had decided that our computer project was going to aim for some
kind of a ``Sound-effect processor'', we started looking into how sound-effects
were actually done.

We quickly found out that for the most commonly known, as well as the more
complicated effects, Fourier-transforms were crucially located at the base of
``How to perform sound-effects'' on a computer in a successful manner.

This represented an (until now) unforeseen problem: Fourier-transforms are
algorithmically heavy, meaning we would have to devote more of the FPGA into
circuits which could handle something as intensive as a Fourier-transoform,
especially if we wanted to perform these sound-effects in real-time. In effect,
this revelation forced us to from a very early point to be concerned about
resource management on the FPGA.

\FloatBarrier
\subsection{Heavy Fourier-transforms}\todo{Maybe find better subsection title?}

Looking into which types of Fourier-transform algorithms we could use on an
embedded device, in a manner as efficiently as possible, and yet real-time,
we ended up looking at \todo{Should be some kind of reference here, no?}
Sliding-Discrete-Fourier-Transforms (or more colloquially known as SD-FT's).

%Need some kind of newline here just to get some "breathing space" for the reader between the above text, and below figure

\missingfigure{Maybe insert a figure here showing how the SD-FT works on each
sample at a time?}

This would enable us to receive a live stream of samples from an input device
through a mini-jack on the PCB, or just from the DMA's of the MCU if the input
was a file on a SD-card. And then transform this live stream of samples into
the frequency domain.

Since we now were able to work on each discrete sample while it was in the
frequency domain, we were now able to perform things like basic high-pass and
low-pass filters.

The magic of our sound-effects could be put to work.

\FloatBarrier
\subsection{Sequential processing cores?}\todo{Maybe find better subsection
title?}

Not all of the known sound-effects require (or are even possible) with a
Fourier-transform. Therefore it also became evident that for effects like say
the ``Echo-effect'', we would need to do some post-processing after having
performed the inverse-Fourier-transform of the \todo{Reference of some kind
here?}
SD-FT\footnote{This is discussed in more detail in section
\ref{subsubsection:fpga-alu-ft}.}.

Thus, so far this project required one processor-core to perform the SD-FT, and
then another to perform the actual sound-effect done with the samples in the
frequency domain, another core for the inverse SD-FT, and finally one core for
any possible \todo{Rephrase this better?}
``Non-Fourier-Transform-Needed-Sound-Effect''.

With that reasoning in mind, we would need at least four processing cores, and
this for only one sound-channel. So for every sound-channel needed (stereo needs
two), we would have to add another four processor cores onto the FPGA-chip.

And since we did not want to be delinquents listening to the awesome \todo{
reference to some beatles source here}
Bitless with only mono sound (one sound-channel), we knew from then on that we
would need to implement at the very least eight processor cores in some form of
pipeline or other.

\FloatBarrier
\subsection{Processing cores, 1-on-1}\todo{Maybe find better subsection title?}

Knowing we would need a minimum of eight processor cores on our FPGA processor,
and maybe more later down the line, we decided to start making things easier
for ourselves.

We decided on making all the cores homogenous, so that we could send the same
instructions to any core, being safe in the knowledge that any core could
perform said instructions.

This simplified our work in VHDL a lot, since we could then just focus on
getting \emph{one} processor core functioning, instead of say one for the SD-FT,
another for the actual sound-effects performed in the frequency domain, a third
for the inverse-SD-FT, and then a fourth for the final ``post-processing''.
(Which could in all likelyhood have more than quadrupled the work of the
VHDL-aspect of this project).

Due to all of the members in the FPGA-group taking the course TDT4255 \emph{
Computer Design}
it may come as no surprise to any reader familiar with the courses at IDI, NTNU,
that this course was a big source of inspiration for the development of our
processor-core.

Both the \todo{Need reference to the book here} book and the programming
exercises were by and large used for the sole purpose of designing a MIPS
processor, which we then had to pipeline.

We had already settled on a processor design having pipelined cores, so why not
use the tried-and-proven performance boost of pipelined processor cores as well?
